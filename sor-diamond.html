<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<title>SoR Diamond Game</title>
<link rel="stylesheet" href="../sor-game/css/sor-game.css"/>
<script src="../sor-game/js/jquery-1.11.3.min.js"></script>

<style type="text/css">

</style>

</head>
<body style="background: #fff0" >	
	<div class="sorGameArea diamond" id="diamondMainDiv">		
		<div class="modeBtnsDiv" id="diamondModeDiv">
            <div class="titleDiv">				
                <span id="titleDiv">PA連線</span>
            </div>		
			<button class="modeBtn" onclick="startGame();">開始遊戲</button>
		</div>
		<div class="diamondGameDiv" id="diamondGameDiv" style="display:none;">
			<input type="hidden" id="score" value="" />
			<div style="display:none;">
				<img id="img_0" src="../sor-game/image/diamond/item_01.png"/>
				<img id="img_1" src="../sor-game/image/diamond/item_02.png"/>
				<img id="img_2" src="../sor-game/image/diamond/item_03.png"/>
				<img id="img_3" src="../sor-game/image/diamond/item_04.png"/>
				<img id="img_4" src="../sor-game/image/diamond/item_05.png"/>

				<!-- 點到的寶石變黃底 -->
				<img id="img_0_s" src="../sor-game/image/diamond/item_01_s.png"/>
				<img id="img_1_s" src="../sor-game/image/diamond/item_02_s.png"/>
				<img id="img_2_s" src="../sor-game/image/diamond/item_03_s.png"/>
				<img id="img_3_s" src="../sor-game/image/diamond/item_04_s.png"/>
				<img id="img_4_s" src="../sor-game/image/diamond/item_05_s.png"/>	
			</div>
			<canvas id="playArea" width="882" height="588" class="diamondGame"></canvas>
			<div class="record">
				<img class="logo" src="../sor-game/image/logo.png">
				<div class="titleDiv">				
					<span id="titleDiv">PA連線</span>
				</div>		
				<div class="timeDiv" id="timeDiv">				
					剩餘時間：<span id="timeCount">0</span>
				</div>
				<div class="scoreDiv">				
					分數：<span id="gameScore">0</span>
				</div>					
				<button type="button" class="restartBtn" onclick="startGame();">重新開始</button>	
				<img class="logo" src="../sor-game/image/andygo.png">
			</div>			
		</div>
	</div>
	
<script>
var zoomPercent = 1;  // Global variable
$(document).ready(function() {	
	$("body").css("zoom", zoomPercent);
});

/**
 * 選擇王國連線模式
 */
function startGame() {
	$("#diamondModeDiv").hide();	//隱藏模式選單
	$("#diamondGameDiv").show();	//顯示遊戲畫面	
	gamestart = true;
	gameover = false;	
	clearInterval(downloadTimer);
	$("#timeDiv").show();
	$("#timeCount").text("0");	
	init();
}

var canvas = document.getElementById("playArea");
var context = canvas.getContext("2d");
//Timing and frames per second
var lastframe = 0;
//可否點擊寶石
var drag = false;
var moving = false;
//Level object
var level = {
    x: 0,         // X position
    y: 0,         // Y position
    columns: 9,     // Number of tile columns
    rows: 6,        // Number of tile rows
    tilewidth: 98,  // Visual width of a tile
    tileheight: 98, // Visual height of a tile
    tiles: [],      // The two-dimensional tile array
    selectedtile: { selected: false, column: 0, row: 0 }
};

var clusters = [];  // { column, row, length, horizontal }	//已經完成三個以上相同顏色一組的寶石
var moves = [];     // { column1, row1, column2, row2 }		//移動後可以完成寶石組的寶石

//Current move
var currentmove = { column1: 0, row1: 0, column2: 0, row2: 0 };
// Game states
var gamestates = { init: 0, ready: 1, resolve: 2 };
var gamestate = gamestates.init;
//Score
var score = 0;
//Game Over
var gameover = false;
var gamestart = false;
//Animation variables
var animationState = 0;
var animationTime = 0;
var animationTimeTotal = 0.3;


function init() {
	// Add mouse events
	canvas.addEventListener("mousemove", onMouseMove);
	canvas.addEventListener("mousedown", onMouseDown);
	canvas.addEventListener("mouseup", onMouseUp);
    canvas.addEventListener("mouseout", onMouseOut);
    // Initialize the two-dimensional tile array
    for (var i=0; i<level.columns; i++) {
        level.tiles[i] = [];
        for (var j=0; j<level.rows; j++) {
            // Define a tile type and a shift parameter for animation
            level.tiles[i][j] = { type: 0, shift:0 }
        }        
    }
    //建立新遊戲
    newGame();
    //Loop
    main(0);    
}

var itemClear={};
function newGame() {
	// Reset score
    score = 0;
    itemClear={};
    $("#score").val(score);
    $("#gameScore").text(score);    
    if(gamestart) {    	
    	//判斷遊戲的模式 : 計時模式/次數模式/進階模式
    	var min=0, max=0;
    	//設時間倒數3分鐘
		setTimeCount(180);
    	min = 0;
    	max = 4;
    	for(var i=0; i<5 ; i++) {
    		itemClear["item_"+i] = 0;	
    	}
    }
    
	// Set the gamestate to ready
    gamestate = gamestates.ready;
 	// Reset game over
    gameover = false;
	createLevel();
	findMoves();
	findClusters(); 
}

var timeCount=0;
var downloadTimer;
function setTimeCount(sec) {	
	timeCount = sec;	
	downloadTimer = setInterval(function(){		
		timeCount -= 1;		
		if(timeCount < 0){
			gameover = true;
			clearInterval(downloadTimer);			
		} else {
			$("#timeCount").html(timeCount);						
		}		
	}, 1000);		
}

function main(tframe) {	
	// Request animation frames	
	if(!gameover) {
		window.requestAnimationFrame(main);		//LOOP檢查寶石狀況	
	}	
 	//Update and render the game 	
    update(tframe);
	//畫寶石遊戲的區塊
    render();	
}

//更新目前的寶石狀態
function update(tframe) {
	var dt = (tframe - lastframe) / 1000;
    lastframe = tframe;
	if (gamestate == gamestates.ready) {
		moving = true;
		// Check for game over
        if (moves.length <= 0) {
        	createLevel();            
        }
	} else if (gamestate == gamestates.resolve) {
		moving = false;
		animationTime += dt;
		 if (animationState == 0) {
             // 找到可以消除的寶石組並把寶石消除
             if (animationTime > animationTimeTotal) {
                 // Find clusters
                 findClusters();                 
                 if (clusters.length > 0) {
                     // Add points to the score
                     for (var i=0; i<clusters.length; i++) {
						score += 10 + 5*(clusters[i].length - 3);	//消除3 個 =10 分；消除 4 個 =15 分；消除 5 個 =20 分，以此類推每多一個多 5 分	 
                        //紀錄消除的顏色
                        if(clusters[i].imgId != 5) {
                        	itemClear["item_"+clusters[i].imgId] = parseInt(itemClear["item_"+clusters[i].imgId]) +clusters[i].length;
                        }
                     }                 
                     // Clusters found, remove them
                     removeClusters();                     
                     // Tiles need to be shifted
                     animationState = 1;
                 } else {
                     // No clusters found, animation complete
                     gamestate = gamestates.ready;
                 }
                 animationTime = 0;
                 $("#score").val(score);
                 $("#gameScore").text(score);
                 
             }			 
		 } else if (animationState == 1) {
			 //消除寶石後，從上方隨機掉下寶石填滿陣列
			 if (animationTime > animationTimeTotal) {
				// Shift tiles
                 shiftTiles();
                 
                 // New clusters need to be found
                 animationState = 0;
                 animationTime = 0;
                 
                 // Check if there are new clusters
                 findClusters();
                 if (clusters.length <= 0) {
                     // Animation complete
                     gamestate = gamestates.ready;
                 }				 
			 }			 
		 } else if (animationState == 2) {
			 //兩個寶石交換
			 if (animationTime > animationTimeTotal) {
				 swap(currentmove.column1, currentmove.row1, currentmove.column2, currentmove.row2);
				 // 判斷交換後的寶石是否可以消滅
				 findClusters();
				 if (clusters.length > 0) {
					//交換後可以消除
					 animationState = 0;	
                     animationTime = 0;
                     gamestate = gamestates.resolve;
				 } else {
					//交換後不可以消除
					 animationState = 3;	
					 animationTime = 0;
				 }
				 // 交換後更新移動後形成寶石組的寶石 & 三個一組的寶石組
                 findMoves();
                 findClusters();
			 }		
		 } else if (animationState == 3) {
			 // 交換後不可以消除
             if (animationTime > animationTimeTotal) {
                 // Invalid swap, swap back
                 swap(currentmove.column1, currentmove.row1, currentmove.column2, currentmove.row2);
                 
                 // Animation complete
                 gamestate = gamestates.ready;
             }
		 }	
		// Update moves and clusters
         findMoves();
         findClusters();
	}
}

//移除掉三個一組的寶石串，且替換掉不同顏色的寶石
function resolveClusters() {
    // Check for clusters
    findClusters();    
    // While there are clusters left    
    while (clusters.length > 0) {
        // 刪掉三個一組的寶石組
        removeClusters();        
        // 替換成其他顏色
        shiftTiles();        
        // 再確認一次是否有三個一組的寶石組
        findClusters();      
    }    
}
//Loop over the cluster tiles and execute a function
function loopClusters(func) {
    for (var i=0; i<clusters.length; i++) {
        //  { column, row, length, horizontal }
        var cluster = clusters[i];
        var coffset = 0;
        var roffset = 0;
        for (var j=0; j<cluster.length; j++) {
            func(i, cluster.column+coffset, cluster.row+roffset, cluster);
            
            if (cluster.horizontal) {
                coffset++;
            } else {
                roffset++;
            }
        }
    }
}
//替換成其他顏色
function shiftTiles() {
    // Shift tiles
    for (var i=0; i<level.columns; i++) {
        for (var j=level.rows-1; j>=0; j--) {
            // Loop from bottom to top
            if (level.tiles[i][j].type == -1) {
                // Insert new random tile
                level.tiles[i][j].type = getRandomTile();
            } else {
                // Swap tile to shift it
                var shift = level.tiles[i][j].shift;
                if (shift > 0) {
                    swap(i, j, i, j+shift)
                }
            }
            
            // Reset shift
            level.tiles[i][j].shift = 0;
        }
    }
}
//刪掉三個一組的寶石組
function removeClusters() {
    // Change the type of the tiles to -1, indicating a removed tile
    loopClusters(function(index, column, row, cluster) { level.tiles[column][row].type = -1; });

    // Calculate how much a tile should be shifted downwards
    for (var i=0; i<level.columns; i++) {
        var shift = 0;
        for (var j=level.rows-1; j>=0; j--) {
            // Loop from bottom to top
            if (level.tiles[i][j].type == -1) {
                // Tile is removed, increase shift
                shift++;
                level.tiles[i][j].shift = 0;
            } else {
                // Set the shift
                level.tiles[i][j].shift = shift;
            }
        }
    }
}

//在寶石陣列中找到消滅群組 (三個一樣顏色寶石為一個群組)
function findClusters() {
    // Reset clusters
    clusters = []    
    // 找水平寶石的群組
    for (var j=0; j<level.rows; j++) {
        // Start with a single tile, cluster of 1
        var matchlength = 1;
        for (var i=0; i<level.columns; i++) {
            var checkcluster = false;            
            if (i == level.columns-1) {
                // Last tile
                checkcluster = true;
            } else {
                // Check the type of the next tile
                if (level.tiles[i][j].type == level.tiles[i+1][j].type &&
                    level.tiles[i][j].type != -1) {
                    // Same type as the previous tile, increase matchlength
                    matchlength += 1;
                } else {
                    // Different type
                    checkcluster = true;
                }
            }            
            // Check if there was a cluster
            if (checkcluster) {
                if (matchlength >= 3) {
                    // Found a horizontal cluster
                    clusters.push({ column: i+1-matchlength, row:j,
                                    length: matchlength, horizontal: true, imgId:level.tiles[i][j].type });
                }                
                matchlength = 1;
            }
        }
    }

 	// 找垂直寶石的群組
    for (var i=0; i<level.columns; i++) {
        // Start with a single tile, cluster of 1
        var matchlength = 1;
        for (var j=0; j<level.rows; j++) {
            var checkcluster = false;            
            if (j == level.rows-1) {
                // Last tile
                checkcluster = true;
            } else {
                // Check the type of the next tile
                if (level.tiles[i][j].type == level.tiles[i][j+1].type &&
                    level.tiles[i][j].type != -1) {
                    // Same type as the previous tile, increase matchlength
                    matchlength += 1;
                } else {
                    // Different type
                    checkcluster = true;
                }
            }            
            // Check if there was a cluster
            if (checkcluster) {
                if (matchlength >= 3) {
                    // Found a vertical cluster
                    clusters.push({ column: i, row:j+1-matchlength,
                                    length: matchlength, horizontal: false, imgId:level.tiles[i][j].type });
                }                
                matchlength = 1;
            }
        }
    }
}

//找到可以移動後形成寶石組的寶石
function findMoves() {
    // Reset moves
    moves = [];
    
    // 找水平的寶石組
    for (var j=0; j<level.rows; j++) {
        for (var i=0; i<level.columns-1; i++) {
            // Swap, find clusters and swap back
            swap(i, j, i+1, j);	//交換兩個寶石
            findClusters();		//是否有寶石組
            swap(i, j, i+1, j);	//交換回來
            
            // Check if the swap made a cluster
            if (clusters.length > 0) {
                // Found a move
                moves.push({column1: i, row1: j, column2: i+1, row2: j});
            }
        }
    }
    
    // 找垂直的寶石組
    for (var i=0; i<level.columns; i++) {
        for (var j=0; j<level.rows-1; j++) {
            // Swap, find clusters and swap back
            swap(i, j, i, j+1);
            findClusters();
            swap(i, j, i, j+1);
            
            // Check if the swap made a cluster
            if (clusters.length > 0) {
                // Found a move
                moves.push({column1: i, row1: j, column2: i, row2: j+1});
            }
        }
    }
    
    // Reset clusters
    clusters = []
}

function render() {
	// Draw level background
    var levelwidth = canvas.width;
    var levelheight = canvas.height;
  	//console.log(moves)
  	if (!gamestart) {
  		context.clearRect(0, 0, canvas.width, canvas.height);
        
        context.fillStyle = "#ffffff";
        context.font = "48px Verdana";
        drawCenterText("點擊按鈕開始遊戲!", level.x, level.y + levelheight / 2 + 10, levelwidth);        
  	} else {
  		context.clearRect(0, 0, canvas.width, canvas.height);
  		//產生顏色寶石
  	    renderTiles();  	
  	  	//顯示消除的寶石連成一條線
  	  	renderClusters();
  	}
 	// Game Over overlay
    if (gameover) {
    	bonusQuestion();
    	$("#startBtn").show();
    	$("#starQtyDiv").hide();    	
    	context.fillStyle = "#ba681cd1";
        context.fillRect(0, 0, levelwidth, levelheight);
        
        context.fillStyle = "#ffffff";
        context.font = "48px Verdana";
        drawCenterText("Game Over!", level.x, level.y + levelheight / 2 + 10, levelwidth);        
    }
}

function drawCenterText(text, x, y, width) {
    var textdim = context.measureText(text);
    context.fillText(text, x + (width-textdim.width)/2, y);
}
//產生顏色寶石
function renderTiles() {
	for (var i=0; i<level.columns; i++) {
		for (var j=0; j<level.rows; j++) {		
			var shift = level.tiles[i][j].shift;			                
			//計算寶石的座標
			var coord = getTileCoordinate(i, j, 0, (animationTime / animationTimeTotal) * shift);
			//將每個寶石座標加上圖片
            if (level.tiles[i][j].type >= 0) {
            	drawTile(coord.tilex, coord.tiley, level.tiles[i][j].type, "");
            } 
			//console.log("X" + i + "//Y" + j +"///" + level.tiles[i][j].type)
			//有選擇寶石
			if (level.selectedtile.selected) {
				if (level.selectedtile.column == i && level.selectedtile.row == j) {
					//選到的寶石
					drawTile(coord.tilex, coord.tiley, level.tiles[i][j].type, "selected");                        
				}
			}
		}		
	}    
	
	// 交換寶石的動畫 (animationState:交換後可以消除、animationState:交換後不可消除)	
    if (gamestate == gamestates.resolve && (animationState == 2 || animationState == 3)) {
        // Calculate the x and y shift
        var shiftx = currentmove.column2 - currentmove.column1;
        var shifty = currentmove.row2 - currentmove.row1;

        // First tile
        var coord1 = getTileCoordinate(currentmove.column1, currentmove.row1, 0, 0);
        var coord1shift = getTileCoordinate(currentmove.column1, currentmove.row1, (animationTime / animationTimeTotal) * shiftx, (animationTime / animationTimeTotal) * shifty);
                
        // Second tile
        var coord2 = getTileCoordinate(currentmove.column2, currentmove.row2, 0, 0);
        var coord2shift = getTileCoordinate(currentmove.column2, currentmove.row2, (animationTime / animationTimeTotal) * -shiftx, (animationTime / animationTimeTotal) * -shifty);
                
        // 交換的兩個寶石移除寶石圖        
        drawTile(coord1.tilex, coord1.tiley, level.tiles[currentmove.column1][currentmove.row1].type, "transparent");         
        drawTile(coord2.tilex, coord2.tiley, level.tiles[currentmove.column2][currentmove.row2].type, "transparent");
                
        // Change the order, depending on the animation state
        if (animationState == 2) {
            // Draw the tiles
            drawTile(coord1shift.tilex, coord1shift.tiley, level.tiles[currentmove.column1][currentmove.row1].type, "swap");
            drawTile(coord2shift.tilex, coord2shift.tiley, level.tiles[currentmove.column2][currentmove.row2].type, "swap");
        } else {
            // Draw the tiles
            drawTile(coord2shift.tilex, coord2shift.tiley, level.tiles[currentmove.column2][currentmove.row2].type, "swap");
            drawTile(coord1shift.tilex, coord1shift.tiley, level.tiles[currentmove.column1][currentmove.row1].type, "swap");
        }        
    }	
}

//將三個寶石組畫上線
function renderClusters() {
    for (var i=0; i<clusters.length; i++) {
        // Calculate the tile coordinates
        var coord = getTileCoordinate(clusters[i].column, clusters[i].row, 0, 0);
        
        if (clusters[i].horizontal) {
            // Draw a horizontal line
            context.fillStyle = "#fd0";
            context.fillRect(coord.tilex + level.tilewidth/2, coord.tiley + level.tileheight/2-10, (clusters[i].length - 1) * level.tilewidth, 20);
        } else {
            // Draw a vertical line
            context.fillStyle = "#fd0";
            context.fillRect(coord.tilex + level.tilewidth/2-10, coord.tiley + level.tileheight/2, 20, (clusters[i].length - 1) * level.tileheight);
        }
    }
}

//寶石的座標位置
function getTileCoordinate(column, row, columnoffset, rowoffset) {
    var tilex = level.x + (column + columnoffset) * level.tilewidth;
    var tiley = level.y + (row + rowoffset) * level.tileheight;
    //console.log(tilex + "///" + tiley)	
    return { tilex: tilex, tiley: tiley};
}

//Draw a tile with a color
function drawTile(x, y, imgIdx, statuse) {    
    var img = document.getElementById("img_" +imgIdx );    
    var img_select = document.getElementById("img_" +imgIdx + "_s" );
    if(statuse == "selected") {    	
        context.drawImage(img_select, x + 4, y + 4, level.tilewidth - 8, level.tileheight - 8);
    } else if (statuse == "transparent"){
    	context.fillStyle = "#fff";
    	context.fillRect(x + 4, y + 4, level.tilewidth - 8, level.tileheight - 8);
    } else if (statuse == "swap"){    	
        context.drawImage(img_select, x + 4, y + 4, level.tilewidth - 8, level.tileheight - 8);
    } else {
    	context.fillStyle = "#fff";
    	context.drawImage(img, x + 4, y + 4, level.tilewidth - 8, level.tileheight - 8);
    }
    
}

// Create a random level
function createLevel() {
	var done = false;
	// Keep generating levels until it is correct
    while (!done) {    	
    	// Create a level with random tiles
        for (var i=0; i<level.columns; i++) {
            for (var j=0; j<level.rows; j++) {
                level.tiles[i][j].type = getRandomTile();
            }
        }
    	    	
        resolveClusters();	// 移除掉三個一組的寶石串
        findMoves();     	// 找到可以移動後形成寶石組的寶石   
        if (moves.length > 0) {
            done = true;
        }
    }	
}

// Get a random tile
function getRandomTile() {
	
	var min=0, max=4; 
	var random = Math.floor(Math.random()*(max-min+1))+min;	//min~max之間取亂數
    return random;
}

//On mouse button click
function onMouseDown(e) {	
    // Get the mouse position
    var pos = getMousePos(canvas, e);
    // 點擊開始拖動寶石
    if ((!drag) && moving) {
        // Get the tile under the mouse
        mt = getMouseTile(pos);    
     	// Valid tile
        var swapped = false;
        if (level.selectedtile.selected) {
            if (mt.x == level.selectedtile.column && mt.y == level.selectedtile.row) {
                // Same tile selected, deselect
                level.selectedtile.selected = false;
                drag = true;
                return;
            } else if (canSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row)){
                // 兩個寶石為鄰近的寶石，允許交換
                mouseSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row);
                swapped = true;
            }            
        }
        //點第一次的寶石
        if (!swapped) {
            // Set the new selected tile
            level.selectedtile.column = mt.x;
            level.selectedtile.row = mt.y;
            level.selectedtile.selected = true;
        }      
        // Start dragging
        drag = true;
    }      
}

//On mouse movement
function onMouseMove(e) {
    // Get the mouse position
    var pos = getMousePos(canvas, e);
    
    // Check if we are dragging with a tile selected
    if (drag && level.selectedtile.selected) {
        // Get the tile under the mouse
        mt = getMouseTile(pos);
     	// Check if the tiles can be swapped
        if (canSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row)){
            // Swap the tiles
            mouseSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row);
        }
    }
}

// 判斷兩個寶石是否是鄰近寶石，可否移動
function canSwap(x1, y1, x2, y2) {
    // Check if the tile is a direct neighbor of the selected tile
    if ((Math.abs(x1 - x2) == 1 && y1 == y2) ||
        (Math.abs(y1 - y2) == 1 && x1 == x2)) {
        return true;
    }
    return false;
}
//將Level array裡的兩個寶石交換
function swap(x1, y1, x2, y2) {
    var typeswap = level.tiles[x1][y1].type;
    level.tiles[x1][y1].type = level.tiles[x2][y2].type;
    level.tiles[x2][y2].type = typeswap;
}
//交換兩個寶石
function mouseSwap(c1, r1, c2, r2) {
    // Save the current move
    currentmove = {column1: c1, row1: r1, column2: c2, row2: r2};

    // 取消先前選取
    level.selectedtile.selected = false;
    
    // Start animation
    animationState = 2;
    animationTime = 0;
    gamestate = gamestates.resolve;
}
function onMouseUp(e) {
    // Reset dragging
    drag = false;
}

function onMouseOut(e) {
    // Reset dragging
    drag = false;
}
//Get the mouse position
function getMousePos(canvas, e) {	
    var rect = canvas.getBoundingClientRect();
    var clientX = e.clientX/zoomPercent;
    var clientY = e.clientY/zoomPercent;
    
    //console.log(rect.left + "---" + rect.top)
    //console.log(clientX + "---" + clientY)    
    //console.log(Math.round((clientX - rect.left)/(rect.right - rect.left)*canvas.width)+"////"+Math.round((clientY - rect.top)/(rect.bottom - rect.top)*canvas.height))
    return {
        x: Math.round((clientX - rect.left)/(rect.right - rect.left)*canvas.width+1),
        y: Math.round((clientY - rect.top)/(rect.bottom - rect.top)*canvas.height+1)
    };
}

//Get the tile under the mouse
function getMouseTile(pos) {
	//console.log("pos.x" + pos.x )
	//console.log("pos.y" + pos.y )
    // Calculate the index of the tile
    var tx = Math.floor((pos.x - level.x) / level.tilewidth);
    var ty = Math.floor((pos.y - level.y) / level.tileheight);
    //console.log(tx + "---" + ty)
    return {        
        x: tx,
        y: ty
    };
}


</script>
</body>
</html>

